.template 0
###############################################################################
# Copyright (c) 2011-2014 libbitcoin developers (see COPYING).
#
# GSL generate libbitcoin.pc.in.
#
# This is a code generator built using the iMatix GSL code generation
# language. See https://github.com/imatix/gsl for details.
###############################################################################
# Functions
###############################################################################

function format_boost_libs(configure)
    define item = format_boost_libs.configure
    return defined(item->dependency(is_boost_lib(dependency))) ??\
        "@boost_LIBS@" ? ""
endfunction

function format_compiler_flags(package)
    define item = format_compiler_flags.package
    define compiler_flags = ""
    for item.cflag as Cflag
        compiler_flags = "$(compiler_flags:) -$(Cflag.value:)"
    endfor Cflag
    return trim_left(compiler_flags)
endfunction

function format_output_libs(package)
    define item = format_output_libs.package
    define output_libs = ""
    for item.output as Output
        output_libs = "$(output_libs:) -l$(Output.name:)"
    endfor Output
    return trim_left(output_libs)
endfunction

function format_packages(configure)
    define item = format_packages.configure
    define packages = ""
    for item.dependency as Dependency where is_package(Dependency)
        packages = \
            "$(packages:) lib$(Dependency.name:) >= $(Dependency.version:)"
    endfor Dependency
    return trim_left(packages)
endfunction

function format_unpackaged_libs(configure)
    define item = format_unpackaged_libs.configure
    define unpackaged_lib = ""
    define unpackaged_libs = ""
    define last_unpackaged_lib = ""
    for item.dependency as Dependency where is_unpackaged_lib(Dependency)
        unpackaged_lib = "@$(Dependency.name:)_LIBS@"
        # GSL Bug? locate() and locate_last() appear to be broken.
        #if (!string.locate(unpackaged_libs, unpackaged_lib))
        # HACK, only works if siblings are adjacent!
        if (last_unpackaged_lib <> unpackaged_lib)
            last_unpackaged_lib = unpackaged_lib
            unpackaged_libs = "$(unpackaged_libs:) $(unpackaged_lib:)"
        endif
    endfor Dependency
    return trim_left(unpackaged_libs)
endfunction

###############################################################################
# Generation
###############################################################################
.endtemplate
.template 1
.for repository by name as Repository
.   define out_file = "$(Repository.name:)/$(Repository->package.name:).pc.in"
.   notify(out_file)
.   output(out_file)
.   copyleft(Repository.name)
.   define configure = Repository->configure
.   define package = Repository->package

prefix=@prefix@
exec_prefix=@exec_prefix@
libdir=@libdir@
includedir=@includedir@

Name: $(Repository->package.name:)
Description: $(Repository->package.description:)
URL: $(Repository->package.url:)
Version: @PACKAGE_VERSION@

# Our dependencies that publish package configuration.
Requires: $(format_packages(configure))

# Our own include directory and any other compiler flags we require.
Cflags: -I${includedir} $(format_compiler_flags(package))

# Our own lib and any we require that do not publish package configuration.
Libs: -L${libdir} $(format_output_libs(package)) $(format_boost_libs(configure)) $(format_unpackaged_libs(configure))
.   endfor Repository
.endtemplate