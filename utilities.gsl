.template 0
###############################################################################
# Copyright (c) 2014-2015 libbitcoin developers (see COPYING).
#
# GSL libbitcoin utilities in the 'global' scope.
#
# This is a code generator built using the iMatix GSL code generation
# language. See https://github.com/imatix/gsl for details.
###############################################################################
# Functions
###############################################################################

# Collection utilities.

function set_cursor_begin(element)
    define my.element = set_cursor_begin.element
    for my.element as _element
        new cursor as _cursor
            move _cursor to _element
            return _cursor
        endnew
    endfor
    return set_cursor_end(my.element)
endfunction

# We insert before a dummy element (cursor) at the end of the product.
# This provides a simple workaround for lack of reverse iteration in GSL,
# allowing order preservation and insertion at the end of the list.
# Fortunately extending a list while iterating it does not alter the iteration.
function set_cursor_end(element)
    define my.element = set_cursor_end.element
    new cursor as _cursor
        move _cursor to my.element
        return _cursor
    endnew
endfunction

function clear_cursor(cursor)
    define my.cursor = clear_cursor.cursor
    delete my.cursor
endfunction

# Library Utilities.

function global.find_library_dependency(name, configure)
    define my.configure = find_library_dependency.configure
    if (defined(my.configure))
        return my.configure->dependency(dependency.name = my.name)
    endif
endfunction

function global.is_packaged_library(name, configure)
    define my.configure = is_packaged_library.configure
    define my.dependency = find_library_dependency(my.name, my.configure)?
    return defined(my.dependency) & is_package(my.dependency)
endfunction

# accepts [lib]bitcoin[-include] and returns include.
function global.bitcoin_to_include(library)
    define my.prefix = "bitcoin"
    define my.libprefix = "lib$(my.prefix)"
    if (my.library = my.prefix) | (my.library = my.libprefix)
        return my.prefix
    endif
    my.prefix += "-"
    if (starts_with(my.library, my.prefix))
        return difference(my.library, string.length(my.prefix))
    endif
    my.libprefix += "-"
    if (starts_with(my.library, my.libprefix))
        return difference(my.library, string.length(my.libprefix))
    endif
    abort "The name is not a bitcoin library: $(my.library)"
endfunction

# accepts include and returns bitcoin[-include].
function global.include_to_bitcoin(include)
    define my.prefix = "bitcoin"
    if (my.include = my.prefix)
        return my.include
    endif
    return "$(my.prefix)-$(my.include)"
endfunction

# Dependency Utilities.

function global.match_dependency(dependency, name)
    define my.dependency = match_dependency.dependency
    require(my.dependency, "dependency", "name")
    return my.dependency.name = my.name
endfunction

function global.is_ax_dependency(dependency)
    define my.dependency = is_ax_dependency.dependency
    return match_dependency(my.dependency, "pthread")
endfunction

function global.is_iconv_dependency(dependency)
    define my.dependency = is_iconv_dependency.dependency
    return match_dependency(my.dependency, "iconv")
endfunction

function global.is_boost_dependency(dependency)
    define my.dependency = is_boost_dependency.dependency
    return match_dependency(my.dependency, "boost")
endfunction

function global.is_java_dependency(dependency)
    define my.dependency = is_java_dependency.dependency
    return match_dependency(my.dependency, "java")
endfunction

function global.is_python_dependency(dependency)
    define my.dependency = is_python_dependency.dependency
    return match_dependency(my.dependency, "python")
endfunction

function global.is_boost_lib_dependency(dependency)
    define my.dependency = is_boost_lib_dependency.dependency
    require(my.dependency, "dependency", "name")
    return starts_with(my.dependency.name, "boost_")
endfunction

function global.is_bitcoin_dependency(dependency)
    define my.dependency = is_bitcoin_dependency.dependency
    require(my.dependency, "dependency", "name")
    return starts_with(my.dependency.name, "bitcoin")
endfunction

# TODO: need to use function names as a form of namespace identification
# so that the called can see the parameter as "dependency". This will allow
# room for other similarly-named functions over differently-typed arguments.

# is_package_dependency
function global.is_package(dependency)
    define my.dependency = is_package.dependency
    return defined(my.dependency.version) &\
        !is_boost_dependency(my.dependency) &\
        !is_boost_lib_dependency(my.dependency)
endfunction

function global.is_linked_package_depedency(dependency)
    define my.dependency = is_linked_package_depedency.dependency
    return is_package(my.dependency) & !is_true(_dependency.unlinked)
endfunction

# is_unpackaged_lib_dependency
function global.is_unpackaged_lib(dependency)
    define my.dependency = is_unpackaged_lib.dependency
    return defined(my.dependency.function) &\
        !is_boost_dependency(my.dependency) &\
        !is_boost_lib_dependency(my.dependency)
endfunction

function global.is_optional_element(element)
    define my.element = is_optional_element.element
    return defined(my.element.option)
endfunction

# Test for a flag context.
function global.match_flag_context(flag, context)
    define my.flag = match_flag_context.flag?
    return (my.flag.context ? "") = my.context
endfunction

# Test flag context value.
function global.is_ccc_flag(flag)
    define my.flag = is_ccc_flag.flag?
    return match_flag_context(my.flag, "c")
endfunction
function global.is_cxx_flag(flag)
    define my.flag = is_cxx_flag.flag?
    return match_flag_context(my.flag, "c++")
endfunction
function global.is_cpp_flag(flag)
    define my.flag = is_cpp_flag.flag?
    return match_flag_context(my.flag, "") |\
        match_flag_context(my.flag, "preprocessor")
endfunction
function global.is_link_flag(flag)
    define my.flag = is_link_flag.flag?
    return match_flag_context(my.flag, "link")
endfunction

# Return CPPFLAGS|CFLAGS|CXXFLAGS|LDFLAGS
function get_flags_variable(flag)
    define my.flag = get_flags_variable.flag
    if (is_cpp_flag(my.flag))
        return "CPPFLAGS"    
    elsif (is_ccc_flag(my.flag))
        return "CFLAGS"
    elsif (is_cxx_flag(my.flag))
        return "CXXFLAGS"
    elsif (is_link_flag(my.flag))
        return "LDFLAGS"
    endif
    define my.context = my.flag.context ? ""
    abort "Invalid flag context: '$(my.context)'."
endfunction

function global.get_option_symbol(option)
    define my.option = get_option_symbol.option
    if (defined(my.option))
        require(my.option, "option", "type")
        require(my.option, "option", "name")
        define my.prefix = ""
        if (!is_true(my.option.unprefixed))
            my.prefix = "$(my.option.type:c)_"
        endif
        return "$(my.prefix)$(my.option.name:c)"
    endif
endfunction

function global.find_option_symbol(element, configure)
    define my.element = find_option_symbol.element
    define my.configure = find_option_symbol.configure
    if (is_optional_element(my.element))
        define my.opt = my.configure->option(option.name = my.element.option)?
        if (defined(my.opt))
            return get_option_symbol(my.opt)
        endif
        abort "Symbol not defined for option: $(my.element.option)"
    endif
endfunction

# Build Utilities.

function global.is_gmp_build(build)
    define my.build = is_gmp_build.build
    return my.build.name = "gmp"
endfunction

function global.is_boost_build(build)
    define my.build = is_boost_build.build
    return my.build.name = "boost"
endfunction

function global.is_github_build(build)
    define my.build = is_github_build.build
    return !is_empty(my.build.github)
endfunction

# Debugging utilities.

function global.notify(filename)
    echo "Generating $(my.filename)..."
endfunction

function global.require(node, context, attribute)
    if (!defined(require.node))
        abort "Required node undefined for $(my.context).$(my.attribute)."
    endif
    define my.node = require.node
    if (!defined(my.node.$(my.attribute)))
        abort "Required attribute missing: $(my.context).$(my.attribute)"
    endif
endfunction

function global.trace1(text)
    trace(my.text, 1)
endfunction

function global.trace2(text)
    trace(my.text, 2)
endfunction

function global.trace3(text)
    trace(my.text, 3)
endfunction

function global.trace(text, context)
    if ((global.trace ? 0) = my.context ? 1)
        echo defined(my.text) ?? "---> $(my.text)" ? "undefined trace"
    endif
endfunction

function global.shebang(interpreter)
    write_line("#!/bin/$(my.interpreter)")
endfunction

function global.batch_no_echo()
    write_line("@echo off")
endfunction

# Write one include.
function write_include(path)
    write_line("#include <$(my.path)>")
endfunction

###############################################################################
# Macros
###############################################################################
.endtemplate
.template 1
.
.# Write a line to the template.
.macro global.write_line(text)
$(my.text ? "")
.endmacro
.
.# Write a single indented line to the template.
.macro global.write_line1(text)
    $(my.text ? "")
.endmacro
.
.# Write a double indented line to the template.
.macro global.write_line2(text)
        $(my.text ? "")
.endmacro
.
.macro global.heading1(text)

# $(my.text)
#==============================================================================
.endmacro
.
.macro global.heading2(text)
# $(my.text)
#------------------------------------------------------------------------------
.endmacro
.
.macro global.heading3(text)
# $(my.text)
.endmacro
.
.macro global.copyleft(name)
###############################################################################
#  Copyright (c) 2014-2015 $(my.name) developers (see COPYING).
#
#         GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY
#
###############################################################################
.endmacro
.
.macro global.c_copyleft(name)
///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2014-2015 $(my.name) developers (see COPYING).
//
//        GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY
//
///////////////////////////////////////////////////////////////////////////////
.endmacro
.
.macro global.bat_copyleft(name)
REM ###########################################################################
REM #  Copyright (c) 2014-2015 $(my.name) developers (see COPYING).
REM #
REM #         GENERATED SOURCE CODE, DO NOT EDIT EXCEPT EXPERIMENTALLY
REM #
REM ###########################################################################
.endmacro
.
.endtemplate